# The Subtle Art of Writing Performant React Hooks

When building modern web apps, it’s easy to write hooks that work but are _not exactly efficient_.  
React doesn’t prevent you from adding unnecessary listeners, recalculations, or effects that silently eat away performance.

This post is about one thing: **making hooks fast and lean**.

## Why care about performance?

Most of the time, performance isn’t about raw speed. It’s about **consistency**.  
If your app feels smooth on desktop but sluggish on mobile, your users notice—even if it’s just a 100ms lag.

Here are three core principles:

1. **Minimize re-renders** – expensive UI recalculations should be avoided.
2. **Leverage the browser** – things like `matchMedia` or `IntersectionObserver` are native and optimized.
3. **Clean up after yourself** – memory leaks from lingering event listeners are sneaky killers.

### Example: `useIsMobile()`

Instead of attaching a `resize` event listener that fires **dozens of times per second**, we can rely on the browser’s optimized media query system:

```tsx
import { useEffect, useState } from "react";

export function useIsMobile(breakpoint: number = 768) {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia(`(max-width: ${breakpoint}px)`);
    const handler = (e: MediaQueryListEvent) => setIsMobile(e.matches);

    setIsMobile(mediaQuery.matches);
    mediaQuery.addEventListener("change", handler);

    return () => mediaQuery.removeEventListener("change", handler);
  }, [breakpoint]);

  return isMobile;
}
```
